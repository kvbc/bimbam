extends Node

const PLAYER_SPEED = 500
const PLAYER_IFRAMES = 0.5 # in seconds
const PLAYER_MAX_HP = 5 # in hearts

const ENEMY_STEERING_RAYS = 20
const ENEMY_STEERING_RAY_LENGTH = 150

const BULLET_SPEED = 600
const BULLET_LIFETIME = 5.0 # in seconds

const MAX_MAP_DEPTH = 15

#
#
# Enemy
#
#

class EnemyData:
	var contact_damage : int # in hearts
	var move_speed     : int 
	var bullet_damage  : int # in hearts
	
	func _init (_move_speed, _contact_damage, _bullet_damage):
		move_speed     = _move_speed
		contact_damage = _contact_damage
		bullet_damage  = _bullet_damage

enum EnemyType {
	MENEL,
	CRACKHEAD,
	SKIN
}

#
#
# Direction
#
#

enum Dir {
	LEFT,
	RIGHT,
	UP,
	DOWN
}

func dir_vector (dir):
	return {
		Dir.LEFT  : Vector2.LEFT,
		Dir.RIGHT : Vector2.RIGHT,
		Dir.UP    : Vector2.UP,
		Dir.DOWN  : Vector2.DOWN
	}[dir]

#
#
# Room
#
#

class MapRoom:
	var type  : String # see set_room_as_scene()
	var pos   : Vector2
	var idx   : int # used for the minimap
	var neighbour_left  : MapRoom
	var neighbour_right : MapRoom
	var neighbour_up    : MapRoom
	var neighbour_down  : MapRoom
	
	func _init (_type:String, _x:int, _y:int):
		type = _type
		pos = Vector2(_x, _y)
	
	func GetNeighbour (dir):
		if (dir == Dir.LEFT ): return neighbour_left
		if (dir == Dir.RIGHT): return neighbour_right
		if (dir == Dir.UP   ): return neighbour_up
		if (dir == Dir.DOWN ): return neighbour_down
	
	func HasNeighbour (dir):
		return GetNeighbour(dir) != null
	
	func SetNeighbour (dir, room : MapRoom):
		if   (dir == Dir.LEFT ): neighbour_left  = room
		elif (dir == Dir.RIGHT): neighbour_right = room
		elif (dir == Dir.UP   ): neighbour_up    = room
		elif (dir == Dir.DOWN ): neighbour_down  = room

#
#
# Private
#
#

var room_exits = {} # room type -> room exit dirs - autogenerated in _ready()
var room_types = {} # room exit dir -> room types - autogenerated in _ready()
var xy_map = {}  # vec2 -> MapRoom
var idx_map = [] # idx -> MapRoom
var map = MapRoom.new("2x2", 0, 0) # first MapRoom
var current_room : MapRoom
var current_room_scene
var player = preload("res://Scenes/Player.tscn").instance()

func expand_room (room:MapRoom, depth = 0):
	if (depth >= MAX_MAP_DEPTH):
		return
		
	xy_map[room.pos] = room
	room.idx = idx_map.size()
	idx_map.append(room)
	
	var exits = room_exits[room.type]
	for dir in exits:
		if not room.HasNeighbour(dir):
			var x = room.pos.x + dir_vector(dir).x
			var y = room.pos.y + dir_vector(dir).y
			var opp_dir = OppositeDir(dir)
			
			var next_room = xy_map.get(Vector2(x, y))
			if next_room != null:
				if not next_room.HasNeighbour(opp_dir) and room_exits[next_room.type].has(opp_dir):
					next_room.SetNeighbour(opp_dir, room)
					room.SetNeighbour(dir, next_room)
			elif randi() % 2 == 0:
				var new_type = room_types[opp_dir][randi() % room_types[opp_dir].size()]
				var new_room = MapRoom.new(new_type, x, y)
				new_room.SetNeighbour(opp_dir, room)
				room.SetNeighbour(dir, new_room)
				expand_room(new_room, depth + 1)

func get_room_scene_path (room_type : String):
	return "res://Scenes/Rooms/" + room_type + ".tscn"

func set_room_as_current_scene (room:MapRoom, entered_from_dir = null):
	if current_room != null:
		ALHUD.GetMinimap().MarkRoomInactive(current_room)
	ALHUD.GetMinimap().MarkRoomActive(room)
	
	if player.get_parent() != null:
		player.get_parent().remove_child(player)
		
	get_tree().change_scene(get_room_scene_path(room.type))
	yield(get_tree(), "idle_frame") # change_scene() is deferred
	current_room = room
	current_room_scene = get_tree().current_scene
	current_room_scene.InitRoom(
		room.HasNeighbour(Dir.LEFT),
		room.HasNeighbour(Dir.RIGHT),
		room.HasNeighbour(Dir.UP),
		room.HasNeighbour(Dir.DOWN),
		entered_from_dir
	)
	
	if entered_from_dir != null:
		player.global_position = current_room_scene.GetExitPosition(entered_from_dir) + dir_vector(OppositeDir(entered_from_dir)) * 70
	else:
		player.global_position = Vector2(500, 300)
	
	# workaround, see https://github.com/godotengine/godot/issues/14578
	var cached_collision_layer = player.collision_layer
	var cached_collision_mask = player.collision_mask
	player.collision_layer = 0
	player.collision_mask = 0
	current_room_scene.add_child(player)
	yield(get_tree(), "idle_frame") # do not touch those yields
	yield(get_tree(), "idle_frame")
	player.collision_layer = cached_collision_layer
	player.collision_mask = cached_collision_mask

func HUD_update_player_health ():
	ALHUD.GetHPDisplay().Update(player.GetHealth())

func _ready ():
	# Auto-generate room_exits{} and room_types{}
	# by loading the room scenes and analyzing all the possible exit directions
	var room_scene_names = []
	var room_scenes_dir = Directory.new()
	room_scenes_dir.open("res://Scenes/Rooms/")
	room_scenes_dir.list_dir_begin()
	while true:
		var file_name = room_scenes_dir.get_next()
		if file_name.empty():
			break
		if file_name.ends_with(".tscn"):
			room_scene_names.append(file_name.trim_suffix(".tscn"))
	room_scenes_dir.list_dir_end()
	for room_type in room_scene_names:
		var room = load(get_room_scene_path(room_type)).instance()
		get_tree().get_root().call_deferred("add_child", room)
		yield(room, "ready")
		var exits = room.GetPossibleExitDirections()
		room_exits[room_type] = exits
		for dir in exits:
			if not room_types.has(dir):
				room_types[dir] = []
			room_types[dir].append(room_type)
		room.queue_free()
	
	randomize()
	expand_room(map)
	ALHUD.Init()
	set_room_as_current_scene(map)
	
	if not player.is_inside_tree():
		yield(player, "ready")
	player.connect("damaged", self, "HUD_update_player_health")
	HUD_update_player_health()

#
#
# Public
#
#

func IsBodyPlayer (body: KinematicBody2D):
	return body is preload("res://Scripts/Player.gd")

func GetPlayer ():
	return player

func GetCurrentRoomScene ():
	return current_room_scene

func OppositeDir (dir):
	return {
		Dir.LEFT  : Dir.RIGHT,
		Dir.RIGHT : Dir.LEFT,
		Dir.UP    : Dir.DOWN,
		Dir.DOWN  : Dir.UP
	}[dir]

func DirFromString (dir_str : String):
	return {
		"Left"  : ALMain.Dir.LEFT,
		"Right" : ALMain.Dir.RIGHT,
		"Up"    : ALMain.Dir.UP,
		"Down"  : ALMain.Dir.DOWN
	}[dir_str]

func GetEnemyData (enemy_type):
	return {
		EnemyType.MENEL     : EnemyData.new(250, 1, 0),
		EnemyType.CRACKHEAD : EnemyData.new(250, 1, 1),
		EnemyType.SKIN      : EnemyData.new(250, 1, 0)
	}[enemy_type]

func EnemyNameToType (enemy_name):
	return {
		"Menel"    : EnemyType.MENEL,
		"Crackhead": EnemyType.CRACKHEAD,
		"Skin"     : EnemyType.SKIN
	}[enemy_name]

func MoveLeft   (): set_room_as_current_scene(current_room.GetNeighbour(Dir.LEFT ), Dir.RIGHT)
func MoveRight  (): set_room_as_current_scene(current_room.GetNeighbour(Dir.RIGHT), Dir.LEFT)
func MoveTop    (): set_room_as_current_scene(current_room.GetNeighbour(Dir.UP   ), Dir.DOWN)
func MoveBottom (): set_room_as_current_scene(current_room.GetNeighbour(Dir.DOWN ), Dir.UP)
