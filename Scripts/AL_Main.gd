extends Node

const PLAYER_SPEED = 500
const PLAYER_IFRAMES = 0.5 # in seconds
const PLAYER_MAX_HP = 5 # in hearts

const ENEMY_STEERING_RAYS = 20
const ENEMY_STEERING_RAY_LENGTH = 150

const BULLET_SPEED = 600
const BULLET_LIFETIME = 5.0 # in seconds

const MAX_MAP_DEPTH = 15

#
#
# Enemy
#
#

class EnemyData:
	var contact_damage : int # in hearts
	var move_speed     : int 
	var bullet_damage  : int # in hearts
	
	func _init (_move_speed, _contact_damage, _bullet_damage):
		move_speed     = _move_speed
		contact_damage = _contact_damage
		bullet_damage  = _bullet_damage

enum EnemyType {
	MENEL,
	CRACKHEAD,
	SKIN
}

#
#
# Direction
#
#

enum Dir {
	LEFT,
	RIGHT,
	UP,
	DOWN
}

#
#
# Room
#
#

class RoomChunk:
	var pos : Vector2 # chunk pos
	var room : MapRoom
	var neighbour_left  : RoomChunk
	var neighbour_right : RoomChunk
	var neighbour_up    : RoomChunk
	var neighbour_down  : RoomChunk

	func _init (_room:MapRoom, _pos:Vector2):
		room = _room
		pos = _pos

	func GetRoom ():
		return room

	func GetPosition ():
		return pos

	func GetNeighbour (dir):
		match dir:
			Dir.LEFT : return neighbour_left
			Dir.RIGHT: return neighbour_right
			Dir.UP   : return neighbour_up
			Dir.DOWN : return neighbour_down

	func HasNeighbour (dir):
		return GetNeighbour(dir) != null
		
	func SetNeighbour (dir, chunk : RoomChunk):
		match dir:
			Dir.LEFT : neighbour_left  = chunk
			Dir.RIGHT: neighbour_right = chunk
			Dir.UP   : neighbour_up    = chunk
			Dir.DOWN : neighbour_down  = chunk
		
class MapRoom:
	var type : String # see set_room_as_scene()
	var pos  : Vector2
	var idx  : int # used for the minimap
	var chunks # chunk pos -> RoomChunk
	
	func _init (_type:String, _x:int, _y:int):
		type = _type
		pos = Vector2(_x, _y)
		chunks = {}
		
	func GetChunk (chunk_pos):
		return chunks.get(chunk_pos)
		
	func HasChunk (chunk_pos):
		return GetChunk(chunk_pos) != null
		
	func AddChunk (chunk : RoomChunk):
		chunks[chunk.GetPosition()] = chunk

#
#
# Private
#
#

var room_chunks = {} # room type -> room chunks
var room_types = {} # room exit dir -> room types - autogenerated in _ready()
var room_wall_positions = {} # room type -> room wall positions
var room_chunk_sizes = {} # room type -> room size in chunks
var room_chunk_exit_dirs = {} # room type -> chunk pos -> exit directions
var room_chunk_min = {} # room type -> min chunk pos
var room_chunk_max = {} # room type -> max_chunk_pos
var room_rects = {}
var room_tiles_per_chunk
var xy_map = {}  # vec2 -> MapRoom
var idx_map = [] # idx -> MapRoom
var map = MapRoom.new("2x2", 0, 0) # first MapRoom
var current_room : MapRoom
var current_room_scene
var player = preload("res://Scenes/Player.tscn").instance()

func expand_room (room:MapRoom, depth = 0):
	if (depth >= MAX_MAP_DEPTH):
		return
		
	for chunk_pos in room_chunks[room.type]:
		xy_map[room.pos + chunk_pos] = room
	room.idx = idx_map.size()
	idx_map.append(room)
	
	for chunk_pos in room_chunks[room.type]: # for every chunk
		if not room.HasChunk(chunk_pos): # if it doesnt exist
			var chunk = RoomChunk.new(room, chunk_pos) # create one
			for dir in room_chunk_exit_dirs[room.type][chunk_pos]: # for every chunk's exit direction
				# generate a new neighbour
				var opp_dir = OppositeDir(dir)
				var new_type = ALUtil.RandomArrayElement(room_types[opp_dir])
				
				var x = room.pos.x + chunk_pos.x + DirVector(dir).x
				var y = room.pos.y + chunk_pos.y + DirVector(dir).y
				
				# brute-force first available neighbour's chunk pos matching {dir} for {new_type}
				# updating {x} and {y} accordingly
				var valid = false
				var new_chunk_pos
				for idx in room_chunks[new_type].size():
					new_chunk_pos = room_chunks[new_type][idx]
					if opp_dir in room_chunk_exit_dirs[new_type][new_chunk_pos]:
						var new_x = x - new_chunk_pos.x
						var new_y = y - new_chunk_pos.y
						valid = true
						for _chunk_pos in room_chunks[new_type]:
							if xy_map.has(Vector2(new_x, new_y) + _chunk_pos):
								valid = false
								break
						if valid:
							x = new_x
							y = new_y
							break
				if not valid:
					continue
				
				var new_room = MapRoom.new(new_type, x, y)
				var new_chunk = RoomChunk.new(new_room, new_chunk_pos)
				new_chunk.SetNeighbour(opp_dir, chunk)
				new_room.AddChunk(new_chunk)
				chunk.SetNeighbour(dir, new_chunk)
				expand_room(new_room, depth + 1)
			room.AddChunk(chunk)

func get_room_scene_path (room_type : String):
	return "res://Scenes/Rooms/" + room_type + ".tscn"

func set_room_as_current_scene (room:MapRoom, entered_from_dir = null):
	var new_plr_chunk
	if current_room != null:
		var plr_chunk_pos = current_room_scene.ToChunkPosition(player.global_position)
		var closest_plr_chunk_pos
		for chunk_pos in room_chunks[current_room.type]:
			if closest_plr_chunk_pos == null or plr_chunk_pos.distance_to(chunk_pos) < plr_chunk_pos.distance_to(closest_plr_chunk_pos):
				closest_plr_chunk_pos = chunk_pos
		print(closest_plr_chunk_pos)
		var plr_chunk = current_room.GetChunk(closest_plr_chunk_pos)
		new_plr_chunk = plr_chunk.GetNeighbour(OppositeDir(entered_from_dir))
	
	current_room = room
	ALHUD.GetMinimap().Update()
	
	if player.get_parent() != null:
		player.get_parent().remove_child(player)
		
	get_tree().change_scene(get_room_scene_path(room.type))
	yield(get_tree(), "idle_frame") # change_scene() is deferred
	current_room_scene = get_tree().current_scene
	current_room_scene.Init(
		room,
		entered_from_dir
	)
	
	if entered_from_dir != null:
		player.global_position = current_room_scene.GetExitPosition(new_plr_chunk.GetPosition(), entered_from_dir)
#		player.global_position = Vector2(500, 300)
	else:
		player.global_position = Vector2(500, 300)
	
	# workaround, see https://github.com/godotengine/godot/issues/14578
	var cached_collision_layer = player.collision_layer
	var cached_collision_mask = player.collision_mask
	player.collision_layer = 0
	player.collision_mask = 0
	current_room_scene.add_child(player)
	yield(get_tree(), "idle_frame") # do not touch those yields
	yield(get_tree(), "idle_frame")
	player.collision_layer = cached_collision_layer
	player.collision_mask = cached_collision_mask

func HUD_update_player_health ():
	ALHUD.GetHPDisplay().Update(player.GetHealth())

func _ready ():
	var room_sizes = []
	
	# Auto-generate
	# by loading the room scenes and analyzing all the possible exit directions
	var room_scene_names = []
	var room_scenes_dir = Directory.new()
	room_scenes_dir.open("res://Scenes/Rooms/")
	room_scenes_dir.list_dir_begin()
	while true:
		var file_name = room_scenes_dir.get_next()
		if file_name.empty():
			break
		if file_name.ends_with(".tscn"):
			room_scene_names.append(file_name.trim_suffix(".tscn"))
	room_scenes_dir.list_dir_end()
	#
	var rooms = []
	for room_type in room_scene_names:
		var room = load(get_room_scene_path(room_type)).instance()
		get_tree().get_root().call_deferred("add_child", room)
		yield(room, "ready")
		room_rects[room_type] = room.GetRect()
		room_sizes.append(room.GetInsideSize().x)
		room_sizes.append(room.GetInsideSize().y)
		room_wall_positions[room_type] = room.GetWallPositions()
		for dir in room.GetPossibleExitDirs():
			if not room_types.has(dir):
				room_types[dir] = []
			room_types[dir].append(room_type)
		rooms.append(room)
	#
	room_tiles_per_chunk = ALUtil.GCDArray(room_sizes)
	for idx in rooms.size():
		var room = rooms[idx]
		var room_type = room_scene_names[idx]
		room_chunks[room_type] = room.GetChunks()
		
		var chunk_min = null
		var chunk_max = null
		for chunk_pos in room_chunks[room_type]:
			if chunk_min == null:
				chunk_min = chunk_pos
			else:
				chunk_min.x = min(chunk_min.x, chunk_pos.x)
				chunk_min.y = min(chunk_min.y, chunk_pos.y)
			if chunk_max == null:
				chunk_max = chunk_pos
			else:
				chunk_max.x = max(chunk_max.x, chunk_pos.x)
				chunk_max.y = max(chunk_max.y, chunk_pos.y)
		room_chunk_min[room_type] = chunk_min
		room_chunk_max[room_type] = chunk_max
		
		room_chunk_sizes[room_type] = room.GetInsideSize() / room_tiles_per_chunk
		room_chunk_exit_dirs[room_type] = room.GetPossibleChunkExitDirs()
		room.queue_free()
	
	randomize()
	expand_room(map)
	ALHUD.Init()
	set_room_as_current_scene(map)
	
	if not player.is_inside_tree():
		yield(player, "ready")
	player.connect("damaged", self, "HUD_update_player_health")
	HUD_update_player_health()

#
#
# Public
#
#

func GetRoomTilesPerChunk ():
	return room_tiles_per_chunk

func IsBodyPlayer (body: KinematicBody2D):
	return body is preload("res://Scripts/Player.gd")

func GetPlayer ():
	return player

func GetCurrentRoomScene ():
	return current_room_scene

func GetAllDirs ():
	return [
		Dir.LEFT,
		Dir.RIGHT,
		Dir.UP,
		Dir.DOWN
	]

func OppositeDir (dir):
	return {
		Dir.LEFT  : Dir.RIGHT,
		Dir.RIGHT : Dir.LEFT,
		Dir.UP    : Dir.DOWN,
		Dir.DOWN  : Dir.UP
	}[dir]

func DirFromString (dir_str : String):
	return {
		"Left"  : ALMain.Dir.LEFT,
		"Right" : ALMain.Dir.RIGHT,
		"Up"    : ALMain.Dir.UP,
		"Down"  : ALMain.Dir.DOWN
	}[dir_str]

func DirVector (dir):
	return {
		Dir.LEFT  : Vector2.LEFT,
		Dir.RIGHT : Vector2.RIGHT,
		Dir.UP    : Vector2.UP,
		Dir.DOWN  : Vector2.DOWN
	}[dir]

func GetEnemyData (enemy_type):
	return {
		EnemyType.MENEL     : EnemyData.new(250, 1, 0),
		EnemyType.CRACKHEAD : EnemyData.new(250, 1, 1),
		EnemyType.SKIN      : EnemyData.new(250, 1, 0)
	}[enemy_type]

func EnemyNameToType (enemy_name):
	return {
		"Menel"    : EnemyType.MENEL,
		"Crackhead": EnemyType.CRACKHEAD,
		"Skin"     : EnemyType.SKIN
	}[enemy_name]

func MoveLeft   (room_chunk : RoomChunk): set_room_as_current_scene(room_chunk.GetNeighbour(Dir.LEFT ).GetRoom(), Dir.RIGHT)
func MoveRight  (room_chunk : RoomChunk): set_room_as_current_scene(room_chunk.GetNeighbour(Dir.RIGHT).GetRoom(), Dir.LEFT)
func MoveTop    (room_chunk : RoomChunk): set_room_as_current_scene(room_chunk.GetNeighbour(Dir.UP   ).GetRoom(), Dir.DOWN)
func MoveBottom (room_chunk : RoomChunk): set_room_as_current_scene(room_chunk.GetNeighbour(Dir.DOWN ).GetRoom(), Dir.UP)
